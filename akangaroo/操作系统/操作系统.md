# 第一章 概述

## 操作系统的目标和作用

 - OS的定义：==OS是一组能有效地组织和管理计算机硬件和软件资源，合理地对各类作业进行调度，以及方便用户使用的序的集合==。
 - os的作用：OS的作用可以从用户，资源管理，资源抽象等多个方面来讨论
    1. OS作为用户和计算机硬件系统之间的接口
        - 用户可以通过三种方式使用计算机：
           + 命令方式
           + 窗口方式
           + 系统调用方式和图形 
    2. OS作为计算机系统资源的管理者
        - 在一个计算机系统中，通常含有多种硬件和软件资源，归纳起来和分为四类
            - 处理器
            - 存储器
            - I/O设备
            - 文件
    3. OS用作扩充机器
## 操作系统的发展过程
- **未配置OS的计算机系统**
    - 人工操作方式
    - 脱机输入/输出返回格式
- **单道批处理系统**
- **多道批处理系统**：推进多道批处理系统形成和发展的主要动力是提高系统资源利用率和系统吞吐量
- **分时系统**：推进分时系统形成的主要动力是为了满足用户人-机交互的需求。
    - 特点：多路性，分时性，及时性和交互性。
- **实时系统**
    - 分类：
        - 硬实时任务：系统必须满足任务对截止时间的要求
        - 软实时任务：截止时间不严格
## 操作系统的基本特性
- **并发**：==并发是OS中最重要的特征==
    - 并发：指两个或多个事件在同一时间间隔内发生。
    - 并行：两个或多个事件同一时刻发生。
- **共享**：==并发和共享是OS中两个最基本的特征==。
- **虚拟**
- **异步**
## 操作系统的主要功能

- **处理器管理功能**：可归结于对进程的管理
    - 进程控制
    - 进程同步
    - 进程通信
    - 调度
        - 作业调度：从后备队列中按照一定算法选出若干个作业，并为他们分配所需的资源，将这些作业调入内存后，分别为他们建立进程，使他们都有可能成为可能获得处理机的就绪程序。
        - 进程调度：从进程的就绪队列中按照一定算法选出一个进程，将处理机分配给它，并为他设置运行现场，使其运行。
- **存储器管理功能**
    - 内存分配
    - 内存保护
    - 地址映射
    - 内存扩充
- **设备管理功能**
    - 缓冲管理
    - 设备管理
    - 设备处理
- **文件管理功能**
    - 文件存储空间的管理
    - 目录管理
    - 文件的读写管理和保护
## OS结构设计
- **无结构OS**
- **模块化OS**
- **分层式OS**
- **微内核OS**：可以从下面四个方面对微内核结构的OS进行概述
    - 足够小的内核
    - 基于C/S模式
    - 应用“机制与策略分离策略”
        - 机制：实现某一功能的具体执行机构
        - 策略：在机制的基础上借助于某些参数和算法来实现该功能的优化。
    - 采用OOP技术



# 第二章 进程

## 前驱图和程序执行
- **顺序执行**：特点：顺序性，封闭性，可再现性
    - 可再现性：只要程序执行的环境和初始条件相同，当程序重复执行时，不论它是从头到尾不停顿地执行，还是走走停停地执行，都可获得相同的结果。
- **并发执行**：特点：间断性，失去封闭性，不可再现性
------------------
## 进程的描述

- **进程的定义和特性**
    - PCB（process control block）：进程控制块。
    - 进程实体（进程映像）：由程序段，相关的数据段和PCB三部分构成。
    - 一般情况下，把进程实体简称为进程，例如创建进程，实质是创建进程实体中的PCB，撤销进程实质是撤销进程实体中的PCB。
    > 进程的定义：==进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位==。  

    - 进程的特征：动态性（最基本），并发性，独立性，异步性。
        - 动态性表现在：它由创建而产生，由调度（指CPU的调度）而执行，由撤销而消亡。
    
- **进程的基本状态和转换**
    - 三种基本状态：就绪状态，执行状态，阻塞（等待/封锁）状态。
    - 三种基本状态的转换：
    ```
    就绪状态->执行状态: 进程调度
    执行状态->就绪状态: 时间片完
    执行状态->阻塞状态: I/O请求
    阻塞状态->就绪状态: I/O完成
    ```
    - 创建状态和终止状态：
        - 创建状态：
            1. 首先由进程申请一个空白PCB，并在PCB中填写控制和管理进程的信息
            2. 然后为该进程分配运行时所需要的资源
            3. 把进程转为就绪状态并插入就绪队列之中
        - 终止状态：
            1. 等待系统进行善后处理
            2. 最后将PCB清零，并将PCB空间返还系统。
- **挂起操作和进程状态的转换**
    >**挂起操作引入的原因**：
    >
    >> 1. 终端用户的需要
    >> 2. 父进程请求
    >> 3. 负荷调节的需要
    >> 4. 操作系统的需要
- **进程管理中的数据结构**
     
     1. OS中用于管理控制的数据结构：内存表，设备表，文件表，进程表，通常进程表称为PCB。
     2. 进程控制块PCB的作用：是使一个在多道程序环境下不能独立运行的程序(含数据)，成为一个能独立运行的基本单位，一个能与其它进程并发执行的进程。或者说，OS是根据PCB来对并发执行的进程进行控制和管理的。
     3. PCB中的信息：
        1. 进程标识符：
            - 外部标识符：为了方便用户（进程）对进程的访问
            - 内部标识符：为了方便系统对进程的使用
        2. 处理机状态：也被称为处理机的上下文
        3. 进程调度信息
       4. 进程控制信息
    4. 进程块的组织方式
        - 线性方式
        - 链接方式
        - 索引方式


## 进程控制
进程控制一般是由OS中的原语来实现的，主要就是完成各种状态之间的转换。

- **操作系统内核基本功能**：
    1. 支撑功能
        1. 中断处理
        2. 时钟处理
        3. 原语操作：原语是由若干条指令组成的。之所以称为原语，是因为原语属于原子操作，即操作中的所有指令或动作要么全做，要么不做。换言之，原语是不可分割的基本单位，在执行过程中不允许被中断。
    2. 资源管理功能：
        1. 进程管理
        2. 存储器管理
        3. 设备管理
- **进程的创建**
    > 引起进程创建的事件：
    > > 1. 用户登录
    > > 2. 作业调度
    > > 3. 提供服务
    > > 4. 应用请求
    
    - 进程的阻塞：进程便通过调用阻塞原语block()把自己阻塞。可见，==进程的阻塞是进程自身的一种主动行为==。

## 进程同步

> *进程同步的概念*：==是对多个相关进程在执行次序上进行协调，使并发执行的诸进程能按照一定的规则（或时序）共享系统资源，并能很好地相互合作，从而使程序的执行具有可再现性==。

-  **如何理解同步和互斥的关系**：
1. 同步和互斥都反映了异步环境下并发进程间的相互制约关系，都可以归为同步范畴。
2. 互斥是同步问题的一个特例。
3. 同步要求各个进程间必须按照一定次序进行而互斥只要求各个进程先后进行（亦即，不在同一时间执行），不一定非要严格次序。 所以，从这个方面说，同步比互斥要求更苛刻。
- **实际上，由共享系统资源而造成的对并发进程执行速度的间接制约关系又称为互斥关系。直接制约的并发进程相互合作的制约关系称为同步关系**。
> 临界资源：一次仅允许一个进程使用的资源称为临界资源。  
> 临界区：每个进程中访问临界资源的那段代码称为临界区。

- **同步机制应遵循的规则**：
    1. 空闲让进
    2. 忙则等待
    3. 有限等待
    4. 让权等待（让出CPU）
- **硬件同步机制**：
    - 关中断
    - 利用Test-and-Set指令实现互斥
    - 利用Swap指令实现互斥
- **信号量机制**
    > ==信号量S是一个整数，S大于等于零是代表可供并发进程使用的资源实体数，当S小于零时则表示正在等待使用临界区的进程数。
    > Dijkstra同时提出了对信号量操作的PV原语。==
    
    > P原语操作的动作是：
    > >   1. S减1；
    > >   2. 若S减1后仍大于或等于零，则进程继续执行；
    > >   3. 若S减1后小于零，则该进程被阻塞后进入与该信号相对应的队列中，然后转进程调度。  
    
    > V原语操作的动作是：
    > >  1. S加1；
    > >  2. 若相加结果大于零，则进程继续执行；
    > >  3. 若相加结果小于或等于零，则从该信号的等待队列中唤醒一等待进程，然后再返回原进程继续执行或转进程调度。

    - 整型信号量
    ``` 
    wait(S){
        while(S < 0);   /*do no-op*/
        S--;
        }
        signal(S){
        S++;
    }
    ```
    - 记录型信号量
    ```
    wait(Semaphore *S){
        S->value--;
        if(S->value < 0 )block(S->list);
        }
        signal(Semaphore *s){
        S->value++;
        if(S->value <= 0)wakeup(S->list)
    }
    ```
    - AND型信号量
        - 基本思想：将进程在整个运行过程中需要的所有资源，一次性全部分配给进程，待进程使用完后再一起释放
    - 信号量集
        - 几种特殊的信号量集：
            1. Swait(S,1,0)。这是一种很特殊且很有用的信号量操作。当S≥1时，允许多个进程进入某特定区；当S变为0后，将阻止任何进程进入特定区。换言之，它相当于一个可控开关。 
- **信号量的应用**
    - 利用信号量实现进程互斥
        1. 设置互斥信号量mutex
        2. 将各进程访问该资源的临界区CS置于wait（mutex）和signal（mutex）之间。
            - mutex = 1 ：两个进程皆没有进入需要互斥的临界区
            - mutex = 0 ：一个进程进入临界区，另一个必须等待，挂入阻塞队列
            - mutex = -1：一个进程在临界区运行，另一个因等待阻塞在信号量队列中。
    - 利用信号量实现前驱关系
- **管程机制**
    > 管程的定义：==代表共享资源的数据结构==以及由==对该共享资源数据结构实施的一组过程所组成的资源管理程序==共同构成了一个==操作系统的资源管理模块==。
    - 管程有四部分构成：
        1. 管程的名称
        2. 局部于管程的共享数据结构说明
        3. 对该数据结构进行操作的过程
        4. 对局部于管程的共享数据设置初始化的语句
        
        Monitor monitor _name{  //管程名称
            share varible declarations; //共享变量说明
            cond declarations;          //条件变量说明
            public;                     //能被进程调用的过程
            void P1(){                  //对数据结构操作的过程
                
            }
            void P2(){
                
            }
            {                           //管程主体
                initializtion code      //初始化代码
            }
        }
        


## 经典的进程同步问题

- 生产消费者问题：[CSDN](https://blog.csdn.net/qq_24451605/article/details/49563045)
[csdn](https://blog.csdn.net/liushall/article/details/81569609)
[不能将两个wait顺序调换](https://zhidao.baidu.com/question/188884304.html)

## 题目
- **在生产者—消费者问题中，如果缺少了signal(full)或signal(empty)，对执行结果将会有何影响？**
    - 如果缺少了signal(full)，那么表明从第一个生产者进程开始就没有对信号量full值改变，即使缓冲池存放的产品已满了，但full的值还是0，这样消费者进程在执行wait(full)时会认为缓冲池是空的而取不到产品，那么消费者进程则会一直处于等待状态。

       如果缺少了signal(empty)，例如在生产者进程向n个缓冲区投满产品后消费者进程才开始从中取产品，这时empty=0，full=n，那么每当消费者进程取走一个产品时empty并没有被改变，直到缓冲池中的产品都取走了，empty的值也一直是0，即使目前缓冲池有n个空缓冲区，生产者进程要想再往缓冲池中投放产品会因申请不到空缓冲区而被阻塞。
- **在生产者—消费者问题中，如果将两个wait操作即wait(full)和wait(mutex)互换位置，或者将signal(mutex)和signal(full)互换位置，结果会如何？**
    - 在生产者—消费者问题中，如果将两个wait操作，即wait(full)和wait(mutex)互换位置后，可能引起死锁。考虑系统中缓冲区全满时，若一生产者进程先执行了wait(mutex)操作并获得成功，则当再执行wait(empty)操作时，它将因失败而进入阻塞状态，它期待消费者进程执行signal(empty)来唤醒自己，在此之前，它不可能执行signal(mutex)操作，从而使试图通过执行wait(mutex)操作而进入自己的临界区的其他生产者和所有消费者进程全部进入阻塞状态，这样容易引起系统死锁。

       若signal(mutex)和signal(full)互换位置后只是影响进程对临界资源的释放次序，而不会引起系统死锁，因此可以互换位置。
    
- [习题答案](http://jinhuidong.blog.sohu.com/134359800.html)



# 第三章 处理机调度

调度的实质是一种资源分配

## 处理机调度的层次

- 高级调度：又被称为长程调度或作业调度，对象是作业
- 低级调度：又被称为进程调度或短程调度，对象是进程（或内核级线程）
- 中级调度：引入中级调度的目的是提高内存利用率和系统吞吐量，实质上是存储器管理中的对换功能

周转时间：是指作业被提交给系统开始，到作业完成为止的这段时间间隔（称为作业周转时间）

## 作业与作业调度

### 批处理系统中的作业

- 作业：作业是一个比程序更为广泛的概念，不仅包含了通常的程序和数据，而且应该配有一份作业说明书。在批处理系统中，是以作业为基本单位从外存调入内存的。
- 作业步：每个作业必须经历若干个相对独立，又互相关联的顺序加工步骤才能得到结果，这些加工步骤称为作业步。
- 作业控制块（JCB）：作业在系统中存在的标志，包含了系统对作业进行管理和调度的全部信息。

- 作业运行的三种阶段：收容，运行，完成。
    1. 收容：把用户提交的作业通过某种输入方式或SPOOLing技术输入到硬盘，再为它创建JCB，并把它放入后备队列中（后备状态）
    2. 运行：从第一次进入就绪状态开始，直到它运行结束前（运行状态）
    3. 完成：完成状态。

### 作业调度的主要任务

根据JCB中的信息，检查系统中的资源能否满足作业对资源的需求，按照一定的算法，从外存的后备队列中选取某些作业调入内存，并为他们创建进程，分配必要的资源。

- 在每次执行作业调度时，做出以下两个决定
    1. 接纳多少作业：取决于多道程序度
    2. 接纳哪些作业：取决于调度算法
- 算法
    1. 先来先服务算法FCFS（first come first served）
    2. 短作业优先算法SJF（short job first）
    3. 优先级调度算法
    4. 高相应比有限调度算法：优先权=（等待时间+要求服务时间）/要求服务时间

## 进程调度

1. 进程调度的任务
    1. 保存处理机的现场信息
    2. 按某种算法选取进程
    3. 把处理机分配给进程
2. 进程调度机制
    1. 排队器
    2. 分派器
    3. 上下文切换器
3. 进程调度方式
    1. 非抢占方式
    2. 抢占方式

### 轮转调度算法（RR）

- 在分时系统中，最常用的是基于时间片的轮转调度算法
1. 原理：根据FCFS策略
2. 进程切换时机
    1. 运行进程完成
    2. 时间片用完
3. 时间片大小确定：略大于一次典型交互所需要的时间。

### 优先级调度算法

### 多队列调度算法

### 多级反馈队列调度算法

1. 调度机制
    - 设置多个就绪队列，并为每个队列设置不同的优先级
    - 每个队列采用FCFS算法
    - 按队列优先级调度

### 基于公平原则的调度算法

## 实时调度

### 实时调度的基本条件

1. 提供必要的信息
2. 系统处理能力强
3. 采用抢占式调度机制
4. 具有快速切换机制

### 分类

1. 根据任务性质：
    1. 硬实时调度
    2. 软实时调度
2. 根据抢占机制
    1. 抢占
    2. 非抢占

### 最早截止时间优选EDF算法

### 最低松弛度优先LLF算法

## 死锁

如果一组进程中每一个进程都在等待由该组进程中的其他进程才能引发的事件，那么该组进程是死锁的（Deadlock）

产生死锁的原因：（1）竞争资源；（2）进程间推进顺序非法。

### 产生死锁的四个条件

1. 互斥条件
2. 请求和保持条件
3. 不可抢占条件
4. 循环等待条件

### 处理死锁的方法
主要破坏死锁的后三个条件
1. 预防死锁
2. 避免死锁
3. 检测死锁
4. 解除死锁

#### 预防死锁

#### 避免死锁

实质：系统进行资源分配时，防止系统进入不安全状态。（银行家算法）
银行家算法

#### 死锁的检测
1. 为了能对死锁进行检测：
    1. 必须保存有关资源的请求和分配信息。
    2. 提供一种算法，利用这些信息来检测系统是否进入死锁状态。

死锁定理：S为死锁的充分条件是：当且仅当S状态的资源分配图是不可完全简化的。

#### 死锁的解除
1. 抢占资源
2. 终止进程

# 第四章 存储器管理

## 内存管理的概念

1. 内存空间的分配与回收
    1. 连续分配管理方式
        1. 单一连续分配
        2. 固定分区连续分配
        3. 动态分区连续分配
    2. 非连续分配管理方式
        1. 分页存储管理
        2. 分段存储管理
        3. 段页式存储管理
2. 内存空间的扩充（形成虚拟性）
    1. 覆盖技术
    2. 交换技术
    3. 虚拟存储技术
3. 地址转换
    - 逻辑地址到物理地址的转换
4. 存储保护
    - 保证各进程在自己的内存空间内运行，不会访问越界
    - 两种方法
        - 设置上下限寄存器
        - 利用重定位寄存器，界地址寄存器进行判断

---------------------
- 存储器管理的对象主要是内存
- 可执行存储器：寄存器和主存储器又被称为可执行存储器

### 程序的装入和链接

1. 编译：高级语言->机器语言，由源代码文件生成目标模块
2. 链接：由目标模块生成装入模块，连接后形成完整的逻辑地址
3. 装入：由装入模块装入内存，形成物理地址

### 程序的装入
1. 绝对装入方式：只适用于单道程序环境
2. 可重定位装入方式（静态重定位）：装入程序负责地址转换
3. 动态重定位：运行时进行地址转换

### 程序的链接
1. 静态链接
2. 装入时动态链接
3. 运行时动态链接

## 连续分配存储管理方式

1. 单一连续分配：
    1. 有内部碎片，无外部碎片
    2. 只支持单道程序，内存分为系统区和用户区
2. 固定分区分配：
    1. 有内部碎片，无外部碎片
    2. 两种方法：分区大小相等，分区大小不等
3. 动态分区分配：
    1. 数据结构：空闲分区链，空闲分区表
    2. 无内部碎片，有外部碎片
    3. 外部碎片可用紧凑技术解决

### 动态分区分配算法
1. 首次适应（First Fit）FF算法（按空闲区首地址递增顺序排序）
2. 循环首次适应（Next Fit）NF算法：不再是每次都从链首开始查找，而是从上次找到的空闲分区的下一个分区开始查找。
3. 最佳适应（Best Fit）BF算法（按空闲区大小递增顺序排序）
4. 最坏适应（Worst Fit）WF算法
    1. 优点：剩下的空闲区不至于太小，产生碎片的可能性最小，对中、小作业有利。（按空闲区大小递减顺序排序）

### 基于索引搜索的动态分区算法
1. 快速适应算法
2. 伙伴系统
3. 哈希算法

> 动态可重定位分区分配算法与动态分区分配算法基本上相同，差别仅在于：增加了紧凑功能。

## 对换

## 分页存储管理方式

1. 页面和物理块（大小相同）
2. 页表
3. 地址变换机构借助页表来完成的。
4. 页表大多数在内存中。
5. 具有快表的地址变换机构：两次访存。
6. 访存的有效时间E=a×λ+（t+λ）（1-a）+t = 2t+λ-t×a。
    其中，a是命中率，λ表示查找块表所需要的时间，t表示访问一次内存所需要的时间


​        
## 分段存储管理方式

## 分段分页对比

页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管 理上的需要，完全是系统行为，对用户是不可见的。

段是信息的逻辑单位。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻 辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。 

页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。

分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址。 分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。

分段比分页更容易实现信息的共享和保护。不能被修改的代码称为纯代码或可重入代码（不属于临界资源），这样的代码是可以共享的。可修改的代码是不能共享的

#### 访存次数

1. 页式存储：2
2. 段式存储：2
3. 段页式存储：3
>增加了快表后
1. 快表命中：1
2. 快表未命中：2





# 第五章 虚拟存储技术

- 传统存储管理方式的特征，缺点：
    1. 一次性：作业必须一次性地全部装入内存后才能开始运行
    2. 驻留性：作业被装入内存后，整个作业都一直驻留在内存中。
- 局部性：
    1. 空间局部性：一旦某程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问（典型情况：程序的顺序执行）
    2. 时间局部性：程序地某条指令被执行，则不久后该指令可能再次执行（典型原因：存在着大量循环操作）

----------------
> 虚拟存储器：具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充地一种存储器系统

1. 虚拟存储器特征：
    - 多次性：
    - 对换性：
    - 虚拟性（最重要的特性）
    

### 缺页中断
程序所要访问地页（段）尚未调入内存（称为缺页或缺段），便发出缺页（段）请求。

## 请求分页存储管理方式
请求分页系统是建立在基本分页基础上，为了能支持虚拟存储器功能，而增加了请求调页功能和页面置换功能。

缺页中断是一种特殊的中断，与其他的中断的区别：
1. 在指令执行期间产生和处理中断信号
2. 一条指令在执行期间可能产生多次缺页中断

见书P158页的图

### 请求分页中的内存分配
1. 最小物理块的确定
2. 内存分配策略：
    - 固定分配：每个进程分配一组固定数目的物理块，运行期间不再改变。
    - 可变分配：先为每个进程分配一定数目的物理块，运行期间可做增加或减少
    - 全局置换：如果进程在运行中缺页，则将OS所有保留的空闲块选择一块分配给该进程。
    - 局部置换：如果进程在运行中缺页，只能从分配给进程的n个页面中选择一页换出。
    
| \        | 全局置换 | 局部置换 |
| -------- | -------- | -------- |
| 固定分配 | 无       | *        |
| 可变分配 | *        | *        |

3. 物理块分配算法

### 页面调入策略
1. 何时调入页面
    1. 预调页
    2. 请求调页策略
2. 从何处调入这些页面
3. 如何调入页面

## 页面置换算法

1. 最佳置换算法（理想）
2. 先进先出置换算法：
3. 最近未使用（Least Recently Used）LRU
    - LRU置换算法的硬件支持 ：寄存器或栈。
4. 最少使用（Least Frequently Used）LFU置换算法
5. Clock置换算法

## 抖动与工作集

1. 抖动：同时在系统中运行的进程太多，由此分配给每个进程的物理块太少，不能满足进程正常运行的基本要求。
2. 预防方法：
    - 采取局部置换策略
    - ...



# 第六章 IO

IO设备定义：将数据输入输出到计算机的外部设备

## 分类

1. 使用特性：存储，网络交互
2. 传输速率：低，中，高
3. 信息交换的基本单位
    块设备（速度快，可寻址）
    字符设备（速度慢，不可寻址，常采用中断驱动方式）

> IO设备由机械部件和电子部件组成

## IO控制器（电子部件，设备控制器）

1. 主要功能
    1. 接受CPU发出的命令（要有控制寄存器）
    2. 向CPU报告设备的状态（要有状态寄存器）
    3. 数据交换（要有数据寄存器）
    4. 地址识别（由IO逻辑实现）
2. 组成
    1. CPU与控制器之间的接口
    2. IO逻辑
    3. 控制器与设备之间的接口
3. 两种寄存器编址方式：内存映像IO，独立编址

## IO控制方式

1. 程序直接控制方式（传输单位：字）
2. 中断驱动方式（传输单位：字）
3. DMA控制方式（传输单位：块）
4. 通道控制方式（传输单位：一组块）