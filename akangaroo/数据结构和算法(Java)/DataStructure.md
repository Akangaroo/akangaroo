## 数据结构和算法

1. 程序 = 数据结构 + 算法 
2. 数据结构包括：线性结构和非线性结构
    - 线性结构：
        1. 顺序存储结构(数组)
        2. 链式存储结构(链表)
        - 常见的有：数组，队列，链表，栈
    - 非线性结构：
      
        - 二维数组，多维数组，广义表，树，图

## 稀疏数组
1. 

## 数组模拟队列

1. 先入先出
2. front作为队列的第一个元素的前一个元素，初始值为-1
3. rear作为队列的最后一个元素，初始值为-1
4. 队列满，rear == maxSize - 1
5. 队列空，front == rear 

## 数组模拟环形队列
1. front作为队列的第一个元素，也就是说arr[front]为队列的第一个元素，front初始值为0。
2. rear指向队列最后一个元素的后一个位置，希望空出一个空间作为一个约定。rear的初始值为0。
3. 队列满，条件是(rear+1)%maxSize == front【满】
4. 队列空，条件是rear == front【空】
5. 队列中有效的个数为 (rear + maxSize - front) % maxSize

## 单链表
1. 
-----------------

- 链表是以结点的方式来存储，是链式存储
    - 链式存储即链表的各个结点不一定是连续存储的
- 每个结点包含data域和next域
- 链表分带头结点和不带头节点的链表，根据实际需求
-----------------
- 删除结点：
    1. 先从链表中找到这个结点的前一个结点temp
    2. temp.next = temp.next.next
    3. 被删除的结点，将不会有其它引用指向，将会被垃圾回收机制回收
- 按id的顺序添加
    1. 首先找到需要添加的结点的位置
    2. 新结点.next = temp.next;
    3. temp.next = 新结点; 

## 双向链表

- 遍历：和单链表一样
- 添加（默认添加到双向链表的最后）：
    1. 先找到双向链表最后的结点
    2. temp.next = newNode;
    3. newNode = temp;
- 删除：
    ```
    
    ```
- 更新：和单链表一样

## 环形链表

- 4. 

## 栈

- 后入先出
- 栈的应用：
    1. 子程序的调用
    2. 处理递归调用
    3. 表达式的转换与求值
    4. 二叉树的遍历
    5. 图的深度优先搜索法

## 递归(Recursion)

- 递归就是方法自己调用自己
- 递归能解决的问题
    - 八皇后问题
    - 汉诺塔
    - 阶乘
    - 迷宫
    - 算法：快排，归并排序，二分查找，分治算法

## 时间复杂度
- 一般情况下，**算法中的基本操作语句的重复执行次数是问题规模n的某个函数**，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。
记作**T(n)=O(f(n))**，称O(f(n))为算法的渐进时间复杂度，简称时间复杂度。
- T(n)不同，但时间复杂度可能相同。如：T(n)=n^2^+7n+6与T（n）=3n^2^+2n+2它们的T(n)不同，但时间复杂度相同，都为O(n^2^)
- 计算时间复杂度的方法：
    1. 用常数1代替运行时间中的所有加法常数T(n)=n^2^+7n+6 → T(n)=n^2^+7n+1
    2. 修改后的运行次数函数中，只保留最高阶项T(n)=n^2^+7n+1 → T(n)=n^2^
    3. 去除最高阶项的系数T(n)=n^2^ → T(n)=n^2^ → O(n^2^）
--------------------------------------------
- 常见的时间复杂度
    1. 
---------------------------------------------
![image](DataStructure.assets/9281)

## 排序
- 1. - ）
- **选择排序**
    1. 

- **插入排序**
    1. 
    
- **希尔排序**
    1. 

- **快速排序**
    1. 3. 
    2. 
    
- **归并排序**
    1. 

- **基数排序**
    1. 
- **堆排序**：
    1. 

## 查找

- **线性查找**
    1. 

- **二分查找**
    1. 

- **插值查找**
    1. 
    
- **斐波那契查找**
    1. 

## 哈希表（散列）
- 

## 树
- 
------------
- 树的应用：[堆排序](https://blog.csdn.net/qq_28063811/article/details/93034625)

- 赫夫曼树
    - WPL
    - 路径

-----------

- BST
- 平衡二叉树（AVL）

## 图

1. 图的创建
2. 图的遍历
    1. 深度优先遍历（DFS）
    2. 广度优先遍历（BFS）



## 常用的算法

1. 二分查找非递归形式

2. 分治算法

   汉诺塔问题：ABC三个塔，把A塔的盘移动到C塔。

   如果只有一个盘：A->C

   如果有两个以上的盘：总是可以看作两个盘，最上面的盘和最下面的一个盘。

   1. 先把最上面的盘从A->B
   2. 把最下面的盘移动A->C。
   3. 再把B塔的所有盘移动B->C



