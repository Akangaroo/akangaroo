# 牛客Java题

## 计算机基础

1. &与操作；|或操作；！非操作；~取反操作；

## 另外

1. java,exe是java虚拟机

   javadoc.exe用来制作java文档

   jdb.exe是java的调试器

   javaprof,exe是剖析工具

2. 除了JVM，都是用java语言编写的。

## Java基础

1. 不考虑反射机制，一个子类显式调用父类的构造器必须用super关键字。（是）

2. 静态变量会默认赋初值，成员变量也有默认值，**局部变量和final声明的变量必须手动赋初值**。在方法中的都叫局部变量。

3. 低级向高级是隐式类型转换，高级向低级必须强制类型转换

4. 静态块：用static申明，JVM加载类时执行，仅执行一次
   构造块：类中直接用{}定义，每一次创建对象时执行
   执行顺序优先级：静态块>main()>构造块>构造方法

5. 不会初始化子类的几种

   1. 调用的是父类的static方法或者字段(只会触发子类的加载、父类的初始化，不会导致子类初始化)
   2. 调用的是父类的final方法或者字段
   3. 通过数组来引用,不会触发此类的初始化 .

6. 引用类型作为函数的参数时，复制的是引用的地址，不会产生一个新的T；而如果T是值类型，其作为函数实参时会复制其值，也就是产生了一个新的T。

7. 在JDK1.8之前的版本（不包括JDK1.8），接口中不能有静态方法，抽象类中因为有普通方法，故也可以有静态方法。

   在JDK1.8后（包括JDK1.8），在抽象类中依旧可以有静态方法，同时在接口中也可以定义静态方法了。

8. Java程序初始化工作可以在许多不同的代码块中来完成，它们的执行顺序如下：
   **父类**的静态变量、父类的静态代码块、**子类**的静态变量、子类的静态代码块、
   父类的**非静态**变量、父类的非静态代码块、**父类的构造函数**、
   子类的非静态变量、子类的非静态代码块、子类的构造函数。

9. 声明为public类型的类名必须与文件名相同，默认权限的可以不同

   并且内部类的类名一般与文件名不同

10. Java的跨平台特性是因为JVM的存在， 它可以执行.class字节码文件，而不是.java源代码

11. 序列化的是对象，不是类，类变量不会被序列化

12. 子类不可以继承父类的构造方法，只可以调用父类的构造方法。

13. 重载：函数方法名必须相同，参数列表是否变化，无关返回值。

14. 在方法内定义的变量在使用之前必须初始化，否则报错。

15. 自定义数组的比较equals是比较的是对象的值，Arrays.equals(int[]a,int[]b)比较的是对逐个元素进行比较。

16. java提供了一个系统级的线程，即垃圾回收器线程。用来对每一个分配出去的内存空间进行跟踪。当JVM空闲时，自动回收每块可能被回收的内存，GC是完全自动的，不能被强制执行。程序员最多只能用System.gc()来建议执行垃圾回收器回收内存，但是具体的回收时间，是不可知的。当对象的引用变量被赋值为null，可能被当成垃圾。

17. 接口方法默认是public abstract的，且实现该接口的类中对应的方法的可见性不能小于接口方法的可见性，因此也只能是public的。

18. 重点在于要时刻记得子类重写父类方法，调用时会调用子类重写之后的方法，当然，这一切的前提都是 实例化子类对象

19. Java中对字段属性是静态绑定，方法成员是动态绑定，这里错在：在子类中试图访问父类的private字段，所以编译不通过，将private去掉就可访问，不是动态绑定的问题，它本来就属于静态绑定。

20. 可以把任何一种数据类型的变量赋给Object类型的变量。八大基础数据类型会自动装箱后赋值给Object，所以编译运行都不会报错

21. length得到的是字符，不是字节

22. ```java
    int i = -5;
    i =  ++(i++);
    //单目运算符无法接变量
    ```

23. Java表达式转型规则**由低到高转换**：

    1、所有的byte,short,char型的值将被提升为int型；

    2、如果有一个操作数是long型，计算结果是long型；

    3、如果有一个操作数是float型，计算结果是float型；

    4、如果有一个操作数是double型，计算结果是double型；

    5、被fianl修饰的变量不会自动改变类型，当2个final修饰相操作时，结果会根据左边变量的类型而转化。

24. switch语句后的控制表达式只能是short、char、int、long整数类型和枚举类型，不能是float，double和boolean类型。**String类型是java7开始支持。**

25. 继承，如果父类没有空构造函数，需要类需要在自己的构造函数中显式调用父类的构造函数，否则编译报错。

26. interface中的方法默认为`public abstract`的 ，变量默认为`public static final`

27. boolean 1个字节或4个字节，在java规范2中，如果boolean用于声明一个基本类型变量时占4个字节，如果声明一个数组类型的时候，那么数组中的每个元素占1个字节。

28. 复制的效率System.arraycopy>clone>Arrays.copyOf>for循环

29. synchronized不是修饰变量的 它修饰方法或代码块或对象

30. 1. 基本型和基本型封装型进行 == 运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true；
    2. 两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。
    3. 两个基本型的封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true
    4. 基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行3中的比较。

31. static不能修饰局部变量

32. 抽象类和最终类都可以被**声明**使用。
    这里只是说**“声明”**，并没有说**“实例化”**；如果只是声明是可以的，最常见的使用方式就是

    1、父类类型的引用指向子类的对象；
    2、 接口类型的引用指向该接口的实现类的对象；
    以上两种使用方式也就是所谓的**“向上转型”**。

33. is-a:继承关系 has-a:从属关系 like-a:组合关系

34. 你就把内部类理解成类的成员，成员有4种访问权限吧，内部类也是！分别为private、protected、public以及默认的访问权限

35. 由于构造器的名字必须与类名相同，而匿名类没有类名，所以匿名类不能有构造器。

36. Character.toString(),String.valueOf()返回的都是字符串,只有char变成 int 的时候才会变为对应的assic码

37. 子类重写父类方法时，方法的访问权限不能小于原访问权限，在接口中，方法的默认权限就是public，所以子类重写后只能是public

38. finally 语句块在 catch语句块中的return语句之前执行。**不是return之前，是return执行完成之前，return表达式的结果会暂时保存起来，不会被改变**

39. 对于外部类而言，它也可以使用访问控制符修饰，但外部类只能有两种访问控制级别： public 和默认。因为外部类没有处于任何类的内部，也就没有其所在类的内部、所在类的子类两个范围，因此 private 和 protected 访问控制符对外部类没有意义

    内部类的上一级程序单元是外部类，它具有 4 个作用域：同一个类（ private ）、同一个包（ protected ）和任何位置（ public ）。

    （ 3 ） 因为局部成员的作用域是所在方法，其他程序单元永远不可能访问另一个方法中的局部变量，所以所有的局部成员都不能使用访问控制修饰符修饰。

40. 三元操作符如果遇到可以转换为数字的类型，会做自动类型提升。

    比如

    ```java
    Object o1 = (false) ? new Double(1.0) : new Integer(2);
    System.out.println(o1);
    ```

    会打印2.0

41. jdk1.7之前byte,short ,int ,char

    jdk1.7之后加入String 

42. 静态变量只能在类主体中定义，不能在方法中定义
43. 重写：两同两小一大
    1. 方法名相同，参数名相同
    2. 子类返回值类型小于等于父类返回值类型，子类抛出异常小于等于父类方法抛出的异常
    3. 子类访问权限大于等于父类方法访问权限
44. 

## 反射&&注解

## IO

1. 节点流：从一个节点读取数据

   处理流：对一个已存在的流进行封装

   常用的处理流：

   - 缓冲流：BufferedInputStrean BufferedOutputStream BufferedReader BufferedWriter 增加缓冲功能，避免频繁读写硬盘。

   - 转换流：InputStreamReader OutputStreamReader 实现字节流和字符流之间的转换。
   - 数据流 DataInputStream DataOutputStream 等-提供将基础数据类型写入到文件中，或者读取出来.

2. 简单地说，字符流是字节流根据字节流所要求的编码集解析获得的

   可以理解为字符流=字节流+编码集

3. 抛InterruptedException的代表方法有：当线程在活动之前或活动期间处于正在等待、休眠或占用状态且该线程被中断时，抛出该异常。

   - java.lang.Object 类的 wait 方法
   - java.lang.Thread 类的 sleep 方法
   - java.lang.Thread 类的 join 方法

4. 

## 容器

1. 如何解决哈希冲突？（链表法HashMap，开放定址法ThreadLocal）,之所以采用不同的方式主要是因为：在ThreadLocalMap中的散列值分散得十分均匀，很少会出现冲突。并且ThreadLocalMap经常需要清除无用的对象，使用纯数组更加方便。
2. 线程安全的map:HashTable,SynchronizedMap,ConcurrentHashMap
3. hashMap在单线程中使用大大提高效率，在多线程的情况下使用hashTable来确保安全。hashTable中使用synchronized关键字来实现安全机制，但是synchronized是对整张hash表进行锁定即让线程独享整张hash表，在安全同时造成了浪费。concurrentHashMap采用分段加锁的机制来确保安全
4. Properties实现了Map接口，是线程安全的
5. vector,stack,hashtable,enumeration：线程安全的
6. 

## 多线程

1. **CyclicBarrier和CountDownLatch都可以让一组线程等待其他线程。前者是让一组线程相互等待到某一个状态再执行。后者是一个线程等待其他线程结束再执行。**

2. **Callable中的call比Runnable中的run厉害就厉害在有返回值和可以抛出异常。同时这个返回值和线程池一起用的时候可以返回一个异步对象Future。**

3. **1.sleep()方法**

   在指定时间内让当前正在执行的线程暂停执行，但不会释放“锁标志”。不推荐使用。

   sleep()使当前线程进入阻塞状态，在指定时间内不会执行。

   **2.wait()方法**

   在其他线程调用对象的notify或notifyAll方法前，导致当前线程等待。线程会释放掉它所占有的“锁标志”，从而使别的线程有机会抢占该锁。

   当前线程必须拥有当前对象锁。如果当前线程不是此锁的拥有者，会抛出IllegalMonitorStateException异常。

   唤醒当前对象锁的等待线程使用notify或notifyAll方法，也必须拥有相同的对象锁，否则也会抛出IllegalMonitorStateException异常。

   waite()和notify()必须在synchronized函数或synchronized　block中进行调用。如果在non-synchronized函数或non-synchronized　block中进行调用，虽然能编译通过，但在运行时会发生IllegalMonitorStateException的异常。

   **3.yield方法** 

   暂停当前正在执行的线程对象。

   yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。

   yield()只能使同优先级或更高优先级的线程有执行的机会。 

   **4.join方法**

   等待该线程终止。

   等待调用join方法的线程结束，再继续执行。如：t.join();//主要用于等待t线程运行结束，若无此句，main则会执行完毕，导致结果不可预测。

4. 线程调度分为协同式调度和抢占式调度，Java使用的是抢占式调度，也就是每个线程将由操作系统来分配执行时间，线程的切换不由线程本身来决定（协同式调度）。这就是平***立的原因。

5. **所谓** **volatile的措施，就是**

   **1. 每次从内存中取值，不从缓存中什么的拿值。这就保证了用** **volatile修饰的共享变量，每次的更新对于其他线程都是可见的。**

   **2.** **volatile保证了其他线程的立即可见性，就没有保证原子性。**

   **3.由于有些时候对** **volatile的操作，不会被保存，说明不会造成阻塞。不可用与多线程环境下的计数器。**

6. 第一，记住wait必须要进行异常捕获

   第二，记住调用wait或者notify方法必须采用当前锁调用，即必须采用synchronized中的对象

7. 

## spring

1. PROPAGATION_REQUIRED--支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。 PROPAGATION_SUPPORTS--支持当前事务，如果当前没有事务，就以非事务方式执行。 
   PROPAGATION_MANDATORY--支持当前事务，如果当前没有事务，就抛出异常。 
   PROPAGATION_REQUIRES_NEW--新建事务，如果当前存在事务，把当前事务挂起。 
   PROPAGATION_NOT_SUPPORTED--以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 
   PROPAGATION_NEVER--以非事务方式执行，如果当前存在事务，则抛出异常。

## 数据库

1. 原子性：事务是一组不可分割的操作单元，这组单元要么同时成功要么同时失败（由DBMS的事务管理子系统来实现）；
   一致性：事务前后的数据完整性要保持一致（由DBMS的完整性子系统执行测试任务）；
   隔离性:多个用户的事务之间不要相互影响，要相互隔离（由DBMS的并发控制子系统实现）；
   持久性:一个事务一旦提交，那么它对数据库产生的影响就是永久的不可逆的，如果后面再回滚或者出异常，都不会影响已提交的事务（由DBMS的恢复管理子系统实现的）
2. ResultSet跟普通的数组不同，索引从1开始而不是从0开始

## JVM

1. off-heap叫做堆外内存，将你的对象从堆中脱离出来序列化，然后存储在一大块内存中，这就像它存储到磁盘上一样，但它仍然在RAM中。对象在这种状态下不能直接使用，它们必须首先反序列化，堆外内存不受垃圾收集器管理，也不属于老年代，新生代。

2. 私有:java虚拟机栈，程序计数器，本地方法栈 共享:java堆，方法区

3. Java运行时的数据区包括：（**方法区和堆是线程共享**）
   1.方法区（Method Area） 存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
   2.**堆（Heap） 存放对象实例**，几乎所有对象实例和数组都在这里分配内存。
   
   ​	以上可能会抛出OutOfMemory异常
   
   ​	**栈中只保存方法中的基础数据类型和自定义对象的引用**
   
   3.虚拟机栈（VM Stack） 描述的是Java方法执行的内存模型：每个方法在执行的同时会创建一个Stack Frame（方法运行时的基础数据结构）用于存储局部变量表、操作数栈、动态连接、方法出口等信息
   4.本地方法栈（Native Method Stack） 与虚拟机栈了类似，不过则为虚拟机使用的到的Native方法服务。（有的虚拟机譬如Sun HotSpot虚拟机直接把本地方法栈和虚拟机栈合二为一）
   
   ​	以上可能会抛出StackOutflowError异常
   
   5.程序计数器（Program Counter Register） 可看作当前线程所执行的字节码的行号的标识器
   
4. -Xmx：最大堆大小

   -Xms：初始堆大小

   -Xmn:年轻代大小

   -XXSurvivorRatio=3：代表Eden:Survivor = 3  根据Generation-Collection算法(目前大部分JVM采用的算法)，一般根据对象的生存周期将堆内存分为若干不同的区域，一般情况将新生代分为Eden ，两块Survivor；   计算Survivor大小， Eden:Survivor = 3，总大小为5120,3x+x+x=5120  x=1024

5. 圾回收在jvm中优先级相当相当低。
   B：垃圾收集器（GC）程序开发者只能推荐JVM进行回收，但何时回收，回收哪些，程序员不能控制。
   C：垃圾回收机制只是回收不再使用的JVM内存，如果程序有严重BUG，照样内存溢出。
   D：进入DEAD的线程，它还可以恢复，GC不会回收
   
6. 类加载的过程：加载，验证，准备，解析，初始化。




## 网络编程

服务器端：ServerSocket提供的实例 ServerSocket server = new ServerSocket(端口号) 

客户端：Socket提供的实例 Socket client = new Socket(IP地址，端口号)





## 网络

1. HTTP是“无状态”协议：客户程序每次读取 Web 页面，都打开到 Web 服务器的单独的连接，并且，服务器也不自动维护客户的上下文信息。实现会话跟踪：Cookies，URL重写，隐藏式表单域，Session机制





## 设计模式

1. **桥接模式：**

   **定义** ：将抽象部分与它的实现部分分离，使它们都可以独立地变化。

   **意图** ：将抽象与实现解耦。

2. 

## Java8新特性

Lambda表达式的主要作用就是代替匿名内部类的繁琐语法， 它由三部分组成：

（1） 形参列表。形参列表允许省略形参类型。如果形参列表中只有一个参数，甚至连形参列表的圆括号也可以省略。

（2） 箭头（→）。必须通过英文中画线和大于符号组成。

（3）代码块。如果代码块只包含一条语句，Lambda表达式允许省略代码块的花括号，那么那条语句就不要用花括号表示语句结束。Lambda代码块只有一条return语句，甚至可以省略return关键字。Lambda表达式需要返回值，而它的代码块中仅有一套省略了return的语句。Lambda表达式会自动返回这条语句的值。


