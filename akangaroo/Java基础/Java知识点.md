# Java知识点

## 变量

1. 可以把任何一种数据类型的变量赋给Object类型的变量。八大基础数据类型会自动装箱后赋值给Object，所以编译运行都不会报错

   ```java
   int i = 5;
   Object o = i;
   System.out.println(o);
   ```

2. Java表达式计算转型规则**由低到高转换**

   1. 所有的byte，short，char型的值将被提升为int型；
   2. 如果有一个操作数是long型，计算结果是long型；
   3. 如果有一个操作数是float型，计算结果是float型；
   4. 如果有一个操作数是double型，计算结果是double型；
   5. 被fianl修饰的变量不会自动改变类型，当2个final修饰相操作时，结果会根据左边变量的类型而转化。

3. boolean 1个字节或4个字节，在java规范2中，如果**boolean用于声明一个基本类型变量时占4个字节**，如果**声明一个数组类型的时候，那么数组中的每个元素占1个字节**

4. 静态变量会默认赋初值，成员变量也有默认值，**局部变量和final声明的变量必须手动赋初值**，在方法中的都叫局部变量

5. 低级向高级是隐式类型转换，高级向低级必须强制类型转换

6. 三元操作符如果遇到可以转换为数字的类型，会做自动类型提升。

   ```java
   Object o1 = (false) ? new Double(1.0) : new Integer(2);
   System.out.println(o1);
   // 结果为2.0
   ```






## 流程控制

1. switch语句后的控制表达式只能是short、char、int、long整数类型和枚举类型，不能是float，double和boolean类型。**String类型是java7开始支持。**



## 初始化

1. Java程序初始化工作可以在许多不同的代码块中来完成，它们的执行顺序如下

   > 父类的静态变量、父类的静态代码块、子类的静态变量、子类的静态代码块 
   >
   > 父类的非静态变量、父类的非静态代码块、父类的构造函数
   >
   > 子类的非静态变量、子类的非静态代码块、子类的构造函数

2. 静态块：用static申明，JVM加载类时执行，仅执行一次
   构造块：类中直接用{}定义，每一次创建对象时执行
   **执行顺序优先级：静态块>main()>构造块>构造方法**



## 面向对象基础

1. 引用类型作为函数的参数时，复制的是引用的地址，不会产生一个新的T；而如果T是值类型，其作为函数实参时会复制其值，也就是产生了一个新的T
2. 声明为public类型的类名必须与文件名相同，默认权限的可以不同，并且内部类的类名一般与文件名不同
3. 由于构造器的名字必须与类名相同，而匿名类没有类名，所以匿名类不能有构造器。
4. 因为局部成员的作用域是所在方法，其他程序单元永远不可能访问另一个方法中的局部变量，所以所有的局部成员都不能使用访问控制修饰符修饰，另外static不能修饰局部变量



## 继承

1. 不考虑反射机制，一个子类显式调用父类的构造器必须用super关键字。
2. 继承，如果父类没有空构造函数，需要类需要在自己的构造函数中显式调用父类的构造函数，否则编译报错。
3. 不会初始化子类的几种情况
   1. 调用的是父类的static方法或者字段（只会触发子类的加载、父类的初始化，不会导致子类初始化）
   2. 调用的是父类的final方法或者字段
   3. 通过数组来引用,不会触发此类的初始化
4. 子类不可以继承父类的构造方法，只可以调用父类的构造方法
5. 重载和重写
   - **重写：两同两小一大**
     1. 方法名相同，参数名相同
     2. 子类返回值类型小于等于父类返回值类型，子类抛出异常小于等于父类方法抛出的异常
     3. 子类访问权限大于等于父类方法访问权限
   - **重载：同名不同参，返回值无关**



## 接口和抽象类

1. 在JDK1.8之前的版本（不包括JDK1.8），接口中不能有静态方法，抽象类中既有普通方法，也有静态方法。
   在JDK1.8后（包括JDK1.8），在抽象类中依旧可以有静态方法，同时在接口中也可以定义静态方法了。
2. **interface中的方法默认为public abstract的 ，变量默认为public static final的**
3. 子类重写父类方法时，方法的访问权限不能小于原访问权限，在接口中，方法的默认权限就是public，所以子类重写后只能是public
4. 抽象类中的方法是可以有方法体的。JDK1.8之后，接口中的方法也可以有方法体，用default关键字修饰方法。



抽象类

1. 抽象类中可以构造方法
2. 抽象类中可以存在普通属性，方法，静态属性和方法。
3. 抽象类中可以存在抽象方法。
4. **如果一个类中有一个抽象方法，那么当前类一定是抽象类；抽象类中不一定有抽象方法。**
5. 抽象类中的抽象方法，需要有子类实现，**如果子类不实现，则子类也需要定义为抽象的。**
6. **抽象类不能被实例化，抽象类和抽象方法必须被abstract修饰**

> 关键字使用注意
> 抽象类中的抽象方法（其前有abstract修饰）不能用private、static、synchronized、native访问修饰符修饰。

接口

1. **在接口中只有常量，因为定义的变量，在编译的时候都会默认加上public static final**
2. **在接口中的方法，永远都被public来修饰**。
3. **接口中没有构造方法，也不能实例化接口的对象**。（所以接口不能继承类）
4. 接口可以实现多继承
5. **接口中定义的方法都需要有实现类来实现，如果实现类不能实现接口中的所有方法则实现类定义为抽象类。**
6. **接口可以继承接口，用extends**





## 内部类

1. 对于外部类而言，它可以使用访问控制符修饰，但外部类只能有两种访问控制级别： public 和 默认。因为外部类没有处于任何类的内部，也就没有其所在类的内部、所在类的子类两个范围，因此 private 和 protected 访问控制符对外部类没有意义，内部类的上一级程序单元是外部类，它具有 4 个作用域：同一个类（ private ）、同一个包（ protected ）和任何位置（ public ）。

   > 把内部类理解成类的成员，成员有4种访问权限，内部类也是！分别为private、protected、public以及默认的访问权限





## 序列化

1. 序列化的是对象，不是类，类变量不会被序列化
2. transient关键字：将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会被序列化。





## 异常处理

1. finally 语句块在 catch语句块中的return语句之前执行。**不是return之前，是return执行完成之前，return表达式的结果会暂时保存起来，不会被改变**

   


## IO

1. 节点流：从一个节点读取数据

   处理流：对一个已存在的流进行封装

   常用的处理流：

   - 缓冲流：BufferedInputStrean BufferedOutputStream BufferedReader BufferedWriter 增加缓冲功能，避免频繁读写硬盘。

   - 转换流：InputStreamReader OutputStreamReader 实现字节流和字符流之间的转换。
   - 数据流 DataInputStream DataOutputStream 等-提供将基础数据类型写入到文件中，或者读取出来.

2. 简单地说，字符流是字节流根据字节流所要求的编码集解析获得的，可以理解为字符流=字节流+编码集

3. 抛InterruptedException的代表方法有：当线程在活动之前或活动期间处于正在等待、休眠或占用状态且该线程被中断时，抛出该异常。

   - java.lang.Object 类的 wait 方法
   - java.lang.Thread 类的 sleep 方法
   - java.lang.Thread 类的 join 方法






## 多线程

2. **Callable中的call比Runnable中的run厉害就厉害在有返回值和可以抛出异常。同时这个返回值和线程池一起用的时候可以返回一个异步对象Future。**

5. **所谓** **volatile的措施，就是**

   **1. 每次从内存中取值，不从缓存中什么的拿值。这就保证了用** **volatile修饰的共享变量，每次的更新对于其他线程都是可见的。**

   **2.** **volatile保证了其他线程的立即可见性，就没有保证原子性。**

   **3.由于有些时候对** **volatile的操作，不会被保存，说明不会造成阻塞。不可用与多线程环境下的计数器。**

3. 保证线程安全的前提是必须保证原子性,可见性,有序性，Volatile关键字也不能保证线程的安全性，因为它不具备原子性，它的作用是保证可见性以及防止指令重排序

   



# 数据库

2. ResultSet跟普通的数组不同，索引从1开始而不是从0开始








